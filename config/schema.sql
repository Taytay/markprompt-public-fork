-- Copied from ../../config/schema.sql
-- Users
CREATE TABLE users (
    id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
    updated_at timestamp with time zone,
    full_name text,
    email text UNIQUE NOT NULL,
    avatar_url text,
    has_completed_onboarding boolean NOT NULL DEFAULT FALSE
);

CREATE TABLE public.teams (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4 (),
    inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    slug text NOT NULL UNIQUE,
    name text,
    is_personal boolean DEFAULT FALSE,
    stripe_customer_id text,
    stripe_price_id text,
    billing_cycle_start timestamp with time zone,
    created_by uuid REFERENCES public.users NOT NULL
);

COMMENT ON TABLE public.teams IS 'Teams data.';

-- Projects
CREATE TABLE public.projects (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4 (),
    inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    slug text NOT NULL,
    name text NOT NULL,
    public_api_key text NOT NULL UNIQUE,
    private_dev_api_key text NOT NULL UNIQUE,
    openai_key text,
    github_repo text,
    team_id uuid REFERENCES public.teams ON DELETE CASCADE NOT NULL,
    is_starter boolean NOT NULL DEFAULT FALSE,
    created_by uuid REFERENCES public.users NOT NULL
);

COMMENT ON TABLE public.projects IS 'Projects within a team.';

-- Memberships
CREATE TYPE membership_type AS enum (
    'viewer',
    'admin'
);

CREATE TABLE public.memberships (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4 (),
    inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_id uuid REFERENCES public.users NOT NULL,
    team_id uuid REFERENCES public.teams NOT NULL
);

COMMENT ON TABLE public.memberships IS 'Memberships of a user in a team.';

-- Domains
CREATE TABLE public.domains (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    name text NOT NULL UNIQUE,
    project_id uuid REFERENCES public.projects ON DELETE CASCADE NOT NULL
);

COMMENT ON TABLE public.domains IS 'Domains associated to a project.';

-- Tokens
CREATE TABLE public.tokens (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    value text NOT NULL,
    project_id uuid REFERENCES public.projects ON DELETE CASCADE NOT NULL,
    created_by uuid REFERENCES public.users NOT NULL
);

COMMENT ON TABLE public.tokens IS 'Tokens associated to a project.';

-- Files
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA public;

CREATE TABLE public.files (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    path text NOT NULL,
    meta jsonb,
    project_id uuid REFERENCES public.projects ON DELETE CASCADE NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- File sections
CREATE TABLE public.file_sections (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    file_id bigint NOT NULL REFERENCES public.files ON DELETE CASCADE,
    content text,
    token_count int,
    embedding vector (1536)
);

-- RLS
-- Users
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see themselves." ON users
    FOR SELECT
        USING (auth.uid () = id);

CREATE POLICY "Users can insert their own user." ON users
    FOR INSERT
        WITH CHECK (auth.uid () = id);

CREATE POLICY "Users can update own user." ON users
    FOR UPDATE
        USING (auth.uid () = id);

-- Memberships
ALTER TABLE memberships ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see their own memberships." ON public.memberships
    FOR SELECT
        USING (auth.uid () = user_id);

CREATE POLICY "Users can insert memberships they belong to." ON public.memberships
    FOR INSERT
        WITH CHECK (auth.uid () = user_id);

CREATE POLICY "Users can update their own memberships." ON public.memberships
    FOR UPDATE
        USING (auth.uid () = user_id);

CREATE POLICY "Users can delete their own memberships." ON public.memberships
    FOR DELETE
        USING (auth.uid () = user_id);

-- Teams
ALTER TABLE teams ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see teams they are members of." ON public.teams
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = teams.id));

-- Note: when a user creates a team, they are not yet members. So they should
-- just be able to create teams with no limitations
CREATE POLICY "Users can insert teams." ON public.teams
    FOR INSERT
        WITH CHECK (TRUE);

CREATE POLICY "Users can update teams they are members of." ON public.teams
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = teams.id));

CREATE POLICY "Users can delete teams they are members of." ON public.teams
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = teams.id));

-- Projects
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see projects associated to teams they are members of." ON public.projects
    FOR SELECT
        USING (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = projects.team_id));

CREATE POLICY "Users can insert projects associated to teams they are members of." ON public.projects
    FOR INSERT
        WITH CHECK (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = projects.team_id));

CREATE POLICY "Users can update projects associated to teams they are members of." ON public.projects
    FOR UPDATE
        USING (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = projects.team_id));

CREATE POLICY "Users can delete projects associated to teams they are members of." ON public.projects
    FOR DELETE
        USING (EXISTS (
            SELECT
                1
            FROM
                memberships
            WHERE
                memberships.user_id = auth.uid () AND memberships.team_id = projects.team_id));

-- Files
ALTER TABLE files ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see files associated to projects they have access to." ON public.files
    FOR SELECT
        USING (files.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can insert files associated to projects they have access to." ON public.files
    FOR INSERT
        WITH CHECK (files.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can update files associated to projects they have access to." ON public.files
    FOR UPDATE
        USING (files.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can delete files associated to projects they have access to." ON public.files
    FOR DELETE
        USING (files.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

-- Tokens
ALTER TABLE tokens ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see tokens associated to projects they have access to." ON public.tokens
    FOR SELECT
        USING (tokens.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can insert tokens associated to projects they have access to." ON public.tokens
    FOR INSERT
        WITH CHECK (tokens.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can delete tokens associated to projects they have access to." ON public.tokens
    FOR DELETE
        USING (tokens.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

-- Domains
ALTER TABLE domains ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see domains associated to projects they have access to." ON public.domains
    FOR SELECT
        USING (domains.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can insert domains associated to projects they have access to." ON public.domains
    FOR INSERT
        WITH CHECK (domains.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

CREATE POLICY "Users can delete domains associated to projects they have access to." ON public.domains
    FOR DELETE
        USING (domains.project_id IN (
            SELECT
                projects.id
            FROM
                projects
            LEFT JOIN memberships ON projects.team_id = memberships.team_id
        WHERE
            memberships.user_id = auth.uid ()));

-- File sections
ALTER TABLE file_sections ENABLE ROW LEVEL SECURITY;

-- No policies for file_sections: they are inaccessible to the client,
-- and only edited on the server with service_role access.
-- Triggers
-- This trigger automatically creates a user entry when a new user signs up
-- via Supabase Auth.for more details.
CREATE FUNCTION public.handle_new_user ()
    RETURNS TRIGGER
    AS $$
BEGIN
    INSERT INTO public.users (id, full_name, email, avatar_url)
        VALUES (NEW.id, NEW.raw_user_meta_data ->> 'full_name', NEW.raw_user_meta_data ->> 'email', NEW.raw_user_meta_data ->> 'avatar_url');
    RETURN new;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE PROCEDURE public.handle_new_user ();

-- Teams
CREATE OR REPLACE FUNCTION match_file_sections (project_id uuid, embedding vector (1536), match_threshold float, match_count int, min_content_length int)
    RETURNS TABLE (
        path text,
        content text,
        token_count int,
        similarity float)
    LANGUAGE plpgsql
    AS $$
    # variable_conflict use_variable
BEGIN
    RETURN query
    SELECT
        files.path,
        file_sections.content,
        file_sections.token_count,
        (file_sections.embedding < #> embedding) * -1 AS similarity
    FROM
        file_sections
        JOIN files ON file_sections.file_id = files.id
    WHERE
        files.project_id = project_id
        -- We only care about sections that have a useful amount of content
        AND length(file_sections.content) >= min_content_length
        -- The dot product is negative because of a Postgres limitation, so we negate it
        AND (file_sections.embedding < #> embedding) * -1 > match_threshold
        -- OpenAI embeddings are normalized to length 1, so
        -- cosine similarity and dot product will produce the same results.
        -- Using dot product which can be computed slightly faster.
        --
        -- For the different syntaxes, see https://github.com/pgvector/pgvector
    ORDER BY
        file_sections.embedding < #> embedding
    LIMIT match_count;
END;
$$;

CREATE INDEX idx_project_id ON files (project_id);

CREATE INDEX idx_file_id ON file_sections (file_id);

